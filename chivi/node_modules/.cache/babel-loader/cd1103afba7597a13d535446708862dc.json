{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar React = require('react');\n\nvar React__default = _interopDefault(React);\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n} // \n\n\nvar mapSequenceOverProps = function mapSequenceOverProps(props, id) {\n  var animationStates = props.animationStates,\n      restProps = _objectWithoutProperties(props, [\"animationStates\"]);\n\n  if (!id || !animationStates || !animationStates[id]) return props;\n\n  var stateCopy = _objectSpread({}, animationStates[id]);\n\n  return _objectSpread({}, stateCopy, restProps);\n};\n\nfunction attributesGenerator(props) {\n  var willComplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isMountWithPlay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var animationStates = props.animationStates,\n      sequenceId = props.sequenceId,\n      sequenceIndex = props.sequenceIndex;\n  var id = sequenceId || sequenceIndex;\n\n  var _mapSequenceOverProps = mapSequenceOverProps(props, id),\n      play = _mapSequenceOverProps.play,\n      startStyle = _mapSequenceOverProps.startStyle,\n      endStyle = _mapSequenceOverProps.endStyle,\n      onCompleteStyle = _mapSequenceOverProps.onCompleteStyle,\n      _mapSequenceOverProps2 = _mapSequenceOverProps.durationSeconds,\n      durationSeconds = _mapSequenceOverProps2 === void 0 ? 0.3 : _mapSequenceOverProps2,\n      _mapSequenceOverProps3 = _mapSequenceOverProps.delaySeconds,\n      delaySeconds = _mapSequenceOverProps3 === void 0 ? 0 : _mapSequenceOverProps3,\n      _mapSequenceOverProps4 = _mapSequenceOverProps.easeType,\n      easeType = _mapSequenceOverProps4 === void 0 ? 'linear' : _mapSequenceOverProps4,\n      className = _mapSequenceOverProps.className,\n      _mapSequenceOverProps5 = _mapSequenceOverProps.reverseDurationSeconds,\n      reverseDurationSeconds = _mapSequenceOverProps5 === void 0 ? 0 : _mapSequenceOverProps5,\n      _mapSequenceOverProps6 = _mapSequenceOverProps.reverseDelaySeconds,\n      reverseDelaySeconds = _mapSequenceOverProps6 === void 0 ? 0 : _mapSequenceOverProps6,\n      forwardedRef = _mapSequenceOverProps.forwardedRef;\n\n  var style = startStyle;\n  var transition = \"all \".concat(durationSeconds, \"s \").concat(easeType, \" \").concat(delaySeconds, \"s\");\n\n  if (play !== undefined && !play && (reverseDurationSeconds || reverseDelaySeconds)) {\n    transition = \"all \".concat(reverseDurationSeconds || durationSeconds, \"s \").concat(easeType, \" \").concat(reverseDelaySeconds, \"s\");\n  } else if (!isMountWithPlay) {\n    if (willComplete && onCompleteStyle && play) {\n      style = onCompleteStyle;\n      transition = '';\n    } else if (play || (id || id === 0) && animationStates && Object.keys(animationStates).length && animationStates[id] && animationStates[id].play) {\n      style = endStyle;\n    }\n  }\n\n  return {\n    className: className,\n    style: _objectSpread({}, style, {\n      transition: transition\n    }),\n    ref: forwardedRef\n  };\n} // \n\n\nvar msToSec = function msToSec(ms) {\n  return (parseFloat(ms) || 0) * 1000;\n}; // \n\n\nvar calculateTotalDuration = function calculateTotalDuration(_ref) {\n  var _ref$durationSeconds = _ref.durationSeconds,\n      durationSeconds = _ref$durationSeconds === void 0 ? 0 : _ref$durationSeconds,\n      _ref$delaySeconds = _ref.delaySeconds,\n      delaySeconds = _ref$delaySeconds === void 0 ? 0 : _ref$delaySeconds,\n      _ref$reverseDurationS = _ref.reverseDurationSeconds,\n      reverseDurationSeconds = _ref$reverseDurationS === void 0 ? 0 : _ref$reverseDurationS,\n      play = _ref.play;\n  var duration = parseFloat(play ? durationSeconds : reverseDurationSeconds || durationSeconds) + parseFloat(delaySeconds);\n  return msToSec(duration);\n};\n\nvar AnimateContext = React__default.createContext({\n  animationStates: {},\n  register: function register() {}\n});\n\nvar AnimateGroup =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(AnimateGroup, _React$PureComponent);\n\n  function AnimateGroup() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, AnimateGroup);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimateGroup)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      animationStates: {}\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"timers\", {});\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"animations\", {});\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"clearTimers\", function () {\n      return Object.values(_this.timers).forEach(function (timer) {\n        return clearTimeout(timer);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setupAnimationTimers\", function (_ref) {\n      var totalDuration = _ref.totalDuration,\n          id = _ref.id,\n          restAttributes = _ref.restAttributes,\n          play = _ref.play;\n      var duration = totalDuration - (restAttributes.overlaySeconds || 0) * 1000;\n      _this.timers[id] = setTimeout(function () {\n        _this.setState(function (previousState) {\n          var stateCopy = _objectSpread({}, previousState.animationStates);\n\n          if (!stateCopy[id]) stateCopy[id] = {};\n          Object.entries(restAttributes).forEach(function (_ref2) {\n            var _ref3 = _slicedToArray(_ref2, 2),\n                key = _ref3[0],\n                value = _ref3[1];\n\n            stateCopy[id][key] = value;\n          });\n          stateCopy[id].play = play;\n          return {\n            animationStates: stateCopy\n          };\n        });\n      }, duration < 0 ? 0 : duration);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"calculateSequences\", function () {\n      var _this$props = _this.props,\n          sequences = _this$props.sequences,\n          reverseSequences = _this$props.reverseSequences,\n          play = _this$props.play;\n      var sequencesToAnimate = Array.isArray(sequences) && sequences.length ? sequences : Object.values(_this.animations);\n      var reverseSequencesToAnimate = Array.isArray(reverseSequences) && reverseSequences.length ? reverseSequences : _toConsumableArray(sequencesToAnimate).reverse();\n      return (play ? sequencesToAnimate : reverseSequencesToAnimate).reduce(function (previous, current, currentIndex) {\n        var sequenceId = current.sequenceId,\n            sequenceIndex = current.sequenceIndex,\n            restAttributes = _objectWithoutProperties(current, [\"sequenceId\", \"sequenceIndex\"]);\n\n        var id = sequenceId === undefined && sequenceIndex === undefined ? currentIndex : sequenceId || sequenceIndex;\n        var totalDuration = previous + calculateTotalDuration(_objectSpread({}, _this.animations[id], {\n          play: play,\n          restAttributes: restAttributes\n        }));\n\n        _this.setupAnimationTimers({\n          id: id,\n          totalDuration: currentIndex === 0 ? 0 : previous,\n          restAttributes: restAttributes,\n          play: play\n        });\n\n        return totalDuration;\n      }, 0);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"register\", function (props) {\n      var sequenceIndex = props.sequenceIndex,\n          sequenceId = props.sequenceId;\n      var id = sequenceId || sequenceIndex;\n      if (id === undefined || sequenceIndex && sequenceIndex < 0 || sequenceId && sequenceId === '') return;\n      _this.animations[id] = _objectSpread({}, props);\n    });\n\n    return _this;\n  }\n\n  _createClass(AnimateGroup, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.props.play && this.calculateSequences();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.props.play !== prevProps.play) {\n        this.clearTimers();\n        this.calculateSequences();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearTimers();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React__default.createElement(AnimateContext.Provider, {\n        value: {\n          animationStates: this.state.animationStates,\n          register: this.register\n        }\n      }, this.props.children);\n    }\n  }]);\n\n  return AnimateGroup;\n}(React__default.PureComponent);\n\n_defineProperty(AnimateGroup, \"displayName\", 'AnimateGroup');\n\n_defineProperty(AnimateGroup, \"defaultProps\", {\n  sequences: [],\n  reverseSequences: []\n});\n\nvar AnimateChild =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(AnimateChild, _React$PureComponent);\n\n  function AnimateChild(props) {\n    var _this;\n\n    _classCallCheck(this, AnimateChild);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimateChild).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"isMountWithPlay\", false);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      willComplete: false,\n      play: false\n    });\n\n    var play = props.play,\n        register = props.register;\n    register && register(_this.props);\n\n    if (play) {\n      _this.isMountWithPlay = true;\n      _this.initialPlayTimer = setTimeout(function () {\n        _this.isMountWithPlay = false;\n\n        _this.forceUpdate();\n      }, msToSec(props.delaySeconds));\n    }\n\n    return _this;\n  }\n\n  _createClass(AnimateChild, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          delaySeconds = _this$props.delaySeconds,\n          play = _this$props.play,\n          onCompleteStyle = _this$props.onCompleteStyle,\n          durationSeconds = _this$props.durationSeconds,\n          onComplete = _this$props.onComplete,\n          animationStates = _this$props.animationStates,\n          sequenceId = _this$props.sequenceId,\n          sequenceIndex = _this$props.sequenceIndex;\n      var id = sequenceId || sequenceIndex;\n\n      if ((onComplete || onCompleteStyle) && !this.state.willComplete && (play || id && animationStates && Object.keys(animationStates).length && animationStates[id] && animationStates[id].play)) {\n        clearTimeout(this.completeTimeout);\n        this.completeTimeout = setTimeout(function () {\n          _this2.setState({\n            willComplete: true\n          });\n\n          onComplete && onComplete();\n        }, msToSec(parseFloat(delaySeconds) + parseFloat(durationSeconds)));\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      clearTimeout(this.completeTimeout);\n      clearTimeout(this.unMountTimeout);\n      clearTimeout(this.initialPlayTimer);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          _this$props2$tag = _this$props2.tag,\n          tag = _this$props2$tag === void 0 ? 'div' : _this$props2$tag,\n          children = _this$props2.children,\n          render = _this$props2.render;\n      var props = attributesGenerator(this.props, this.state.willComplete, this.isMountWithPlay);\n      return render ? render(props) : React__default.createElement(tag, props, children);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var animationStates = nextProps.animationStates,\n          play = nextProps.play,\n          sequenceId = nextProps.sequenceId,\n          sequenceIndex = nextProps.sequenceIndex,\n          onCompleteStyle = nextProps.onCompleteStyle,\n          register = nextProps.register;\n      var id = sequenceId || sequenceIndex;\n      var currentPlay = play;\n      register && register(nextProps);\n\n      if (id !== undefined && animationStates && animationStates[id]) {\n        var state = animationStates[id];\n        currentPlay = state.play;\n      }\n\n      return _objectSpread({}, onCompleteStyle && prevState.willComplete ? {\n        willComplete: !(play && !prevState.play && prevState.willComplete)\n      } : null, currentPlay !== prevState.play ? {\n        play: currentPlay\n      } : null);\n    }\n  }]);\n\n  return AnimateChild;\n}(React__default.PureComponent); // $FlowIgnoreLine: flow complain about React.forwardRef disable for now\n\n\n_defineProperty(AnimateChild, \"displayName\", 'Animate');\n\n_defineProperty(AnimateChild, \"defaultProps\", {\n  durationSeconds: 0.3,\n  delaySeconds: 0,\n  easeType: 'linear',\n  sequenceId: undefined,\n  sequenceIndex: undefined,\n  animationStates: undefined\n});\n\nvar animate = React__default.forwardRef(function (props, ref) {\n  return React__default.createElement(AnimateContext.Consumer, null, function (_ref) {\n    var _ref$animationStates = _ref.animationStates,\n        animationStates = _ref$animationStates === void 0 ? {} : _ref$animationStates,\n        _ref$register = _ref.register,\n        register = _ref$register === void 0 ? undefined : _ref$register;\n    return React__default.createElement(AnimateChild, _extends({}, _objectSpread({}, props, {\n      animationStates: animationStates,\n      register: register\n    }), {\n      forwardedRef: ref\n    }));\n  });\n}); // \n\nfunction createStyle(_ref) {\n  var keyframes = _ref.keyframes,\n      animationName = _ref.animationName;\n  var animationLength = keyframes.length;\n  return \"\".concat(keyframes.reduce(function (previous, keyframe, currentIndex) {\n    if (typeof keyframe === 'string') {\n      return \"\".concat(previous, \" \").concat(animationLength === 2 ? currentIndex * 100 : parseFloat((100 / (animationLength - 1)).toFixed(2)) * currentIndex, \"% {\").concat(keyframe, \"}\");\n    } // $FlowIgnoreLine:\n\n\n    return \"\".concat(previous, \" \").concat(Object.keys(keyframe)[0], \"% {\").concat(Object.values(keyframe)[0], \"}\");\n  }, \"@keyframes \".concat(animationName, \" {\")), \"}\");\n} // \n\n\nfunction createTag(_ref) {\n  var keyframes = _ref.keyframes,\n      animationName = _ref.animationName;\n  var styleTag = document.querySelector('style[data-id=rsi]');\n\n  if (!styleTag) {\n    styleTag = document.createElement('style');\n    styleTag.setAttribute('data-id', 'rsi'); // $FlowIgnoreLine:\n\n    document.head.appendChild(styleTag);\n  } // $FlowIgnoreLine\n\n\n  var index = styleTag.sheet.cssRules.length || 0;\n\n  try {\n    // $FlowIgnoreLine\n    styleTag.sheet.insertRule(createStyle({\n      keyframes: keyframes,\n      animationName: animationName\n    }), index);\n  } catch (e) {\n    console.error('react simple animate, error found during insert style ', e); // eslint-disable-line no-console\n  }\n\n  return {\n    styleTag: styleTag,\n    index: index\n  };\n} // \n\n\nfunction createRandomName() {\n  return \"RSI-\".concat(Math.random().toString(36).substr(2, 9));\n} // \n\n\nvar deleteRules = function deleteRules(sheet, deleteName) {\n  var index = Object.values(sheet.cssRules).findIndex(function (_ref) {\n    var name = _ref.name;\n    return name === deleteName;\n  });\n\n  if (index >= 0) {\n    sheet.deleteRule(index);\n  }\n};\n\nvar AnimateKeyframesChild =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(AnimateKeyframesChild, _React$PureComponent);\n\n  function AnimateKeyframesChild() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, AnimateKeyframesChild);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimateKeyframesChild)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      play: false\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"createStyleAndTag\", function () {\n      var keyframes = _this.props.keyframes;\n      _this.animationName = createRandomName();\n\n      var _createTag = createTag({\n        animationName: _this.animationName,\n        keyframes: keyframes\n      }),\n          styleTag = _createTag.styleTag,\n          index = _createTag.index;\n\n      _this.styleTag = styleTag;\n      _this.index = index;\n    });\n\n    return _this;\n  }\n\n  _createClass(AnimateKeyframesChild, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props,\n          register = _this$props.register,\n          play = _this$props.play;\n      this.createStyleAndTag();\n      register && register(this.props);\n\n      if (play) {\n        this.forceUpdate();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      deleteRules(this.styleTag.sheet, this.animationName);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          children = _this$props2.children,\n          play = _this$props2.play,\n          render = _this$props2.render,\n          _this$props2$duration = _this$props2.durationSeconds,\n          durationSeconds = _this$props2$duration === void 0 ? 0.3 : _this$props2$duration,\n          _this$props2$delaySec = _this$props2.delaySeconds,\n          delaySeconds = _this$props2$delaySec === void 0 ? 0 : _this$props2$delaySec,\n          _this$props2$easeType = _this$props2.easeType,\n          easeType = _this$props2$easeType === void 0 ? 'linear' : _this$props2$easeType,\n          _this$props2$playStat = _this$props2.playState,\n          playState = _this$props2$playStat === void 0 ? 'running' : _this$props2$playStat,\n          _this$props2$directio = _this$props2.direction,\n          direction = _this$props2$directio === void 0 ? 'normal' : _this$props2$directio,\n          _this$props2$fillMode = _this$props2.fillMode,\n          fillMode = _this$props2$fillMode === void 0 ? 'none' : _this$props2$fillMode,\n          _this$props2$iteratio = _this$props2.iterationCount,\n          iterationCount = _this$props2$iteratio === void 0 ? 1 : _this$props2$iteratio;\n      var style = play || this.state.play ? {\n        animation: \"\".concat(durationSeconds, \"s \").concat(easeType, \" \").concat(delaySeconds, \"s \").concat(iterationCount, \" \").concat(direction, \" \").concat(fillMode, \" \").concat(playState, \" \").concat(this.animationName)\n      } : null;\n      return render ? render({\n        style: style\n      }) : React__default.createElement(\"div\", style ? {\n        style: style\n      } : null, children);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var animationStates = nextProps.animationStates,\n          play = nextProps.play,\n          sequenceId = nextProps.sequenceId,\n          sequenceIndex = nextProps.sequenceIndex;\n      var id = sequenceId || sequenceIndex;\n      var currentPlay = play;\n\n      if (id !== undefined && animationStates && animationStates[id]) {\n        var state = animationStates[id];\n        currentPlay = state.play;\n      }\n\n      return _objectSpread({}, currentPlay !== prevState.play ? {\n        play: currentPlay\n      } : null);\n    }\n  }]);\n\n  return AnimateKeyframesChild;\n}(React__default.PureComponent); // $FlowIgnoreLine: flow complain about React.forwardRef disable for now\n\n\n_defineProperty(AnimateKeyframesChild, \"displayName\", 'AnimateKeyframes');\n\n_defineProperty(AnimateKeyframesChild, \"defaultProps\", {\n  durationSeconds: 0.3,\n  delaySeconds: 0,\n  easeType: 'linear',\n  render: undefined,\n  playState: 'running',\n  direction: 'normal',\n  fillMode: 'none',\n  iterationCount: 1,\n  children: undefined,\n  sequenceId: undefined,\n  sequenceIndex: undefined,\n  register: undefined\n});\n\nvar animateKeyframes = React__default.forwardRef(function (props, ref) {\n  return React__default.createElement(AnimateContext.Consumer, null, function (_ref) {\n    var _ref$animationStates = _ref.animationStates,\n        animationStates = _ref$animationStates === void 0 ? {} : _ref$animationStates,\n        _ref$register = _ref.register,\n        register = _ref$register === void 0 ? undefined : _ref$register;\n    return React__default.createElement(AnimateKeyframesChild, _extends({}, _objectSpread({}, props, {\n      animationStates: animationStates,\n      register: register\n    }), {\n      forwardedRef: ref\n    }));\n  });\n});\n\nfunction useAnimate() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    durationSeconds: 0.3,\n    delaySeconds: 0,\n    easeType: 'linear',\n    play: false,\n    endStyle: {}\n  };\n  var completeTimeout;\n  var initialPlayTimer;\n  var onComplete = props.onComplete,\n      onCompleteStyle = props.onCompleteStyle,\n      _props$delaySeconds = props.delaySeconds,\n      delaySeconds = _props$delaySeconds === void 0 ? 0 : _props$delaySeconds,\n      _props$durationSecond = props.durationSeconds,\n      durationSeconds = _props$durationSecond === void 0 ? 0.3 : _props$durationSecond;\n\n  var _useState = React.useState(props),\n      _useState2 = _slicedToArray(_useState, 2),\n      animateProps = _useState2[0],\n      setPlay = _useState2[1];\n\n  var play = animateProps.play,\n      willComplete = animateProps.willComplete,\n      isMountWithPlay = animateProps.isMountWithPlay;\n\n  var playFunction = function playFunction(playValue) {\n    var isMountWithPlayValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : animateProps.isMountWithPlay;\n    setPlay(_objectSpread({}, props, {\n      play: playValue,\n      isMountWithPlay: isMountWithPlayValue\n    }));\n  };\n\n  React.useEffect(function () {\n    if ((onComplete || onCompleteStyle) && play) {\n      clearTimeout(completeTimeout);\n      completeTimeout = setTimeout(function () {\n        setPlay(_objectSpread({}, animateProps, {\n          willComplete: true,\n          isMountWithPlay: false\n        }));\n        onComplete && onComplete();\n      }, msToSec(parseFloat(delaySeconds) + parseFloat(durationSeconds)));\n    }\n\n    if (play && props.play && isMountWithPlay === undefined) {\n      initialPlayTimer = setTimeout(function () {\n        playFunction(play, false);\n      }, msToSec(delaySeconds));\n    }\n\n    return function () {\n      clearTimeout(completeTimeout);\n      clearTimeout(initialPlayTimer);\n    };\n  }, [play]);\n  return [{\n    style: attributesGenerator(_objectSpread({}, props, {\n      play: play\n    }), willComplete, isMountWithPlay === undefined ? props.play : isMountWithPlay).style,\n    play: play\n  }, playFunction];\n}\n\nfunction useAnimateKeyframes(props) {\n  var _props$durationSecond = props.durationSeconds,\n      durationSeconds = _props$durationSecond === void 0 ? 0.3 : _props$durationSecond,\n      _props$delaySeconds = props.delaySeconds,\n      delaySeconds = _props$delaySeconds === void 0 ? 0 : _props$delaySeconds,\n      _props$easeType = props.easeType,\n      easeType = _props$easeType === void 0 ? 'linear' : _props$easeType,\n      _props$direction = props.direction,\n      direction = _props$direction === void 0 ? 'normal' : _props$direction,\n      _props$fillMode = props.fillMode,\n      fillMode = _props$fillMode === void 0 ? 'none' : _props$fillMode,\n      _props$iterationCount = props.iterationCount,\n      iterationCount = _props$iterationCount === void 0 ? 1 : _props$iterationCount,\n      _props$playState = props.playState,\n      playState = _props$playState === void 0 ? 'running' : _props$playState,\n      keyframes = props.keyframes;\n\n  var _useState = React.useState(props),\n      _useState2 = _slicedToArray(_useState, 2),\n      animateProps = _useState2[0],\n      setPlay = _useState2[1];\n\n  var playFunction = function playFunction(playValue) {\n    setPlay(_objectSpread({}, props, {\n      play: playValue\n    }));\n  };\n\n  var play = animateProps.play,\n      animationName = animateProps.animationName;\n  React.useEffect(function () {\n    var name = createRandomName();\n\n    var _createTag = createTag({\n      animationName: name,\n      keyframes: keyframes\n    }),\n        styleTag = _createTag.styleTag;\n\n    var localStyleTag = styleTag;\n    setPlay(_objectSpread({}, props, {\n      animationName: name\n    }));\n    return function () {\n      deleteRules(localStyleTag.sheet, name);\n    };\n  }, []);\n  var style = play ? {\n    animation: \"\".concat(durationSeconds, \"s \").concat(easeType, \" \").concat(delaySeconds, \"s \").concat(iterationCount, \" \").concat(direction, \" \").concat(fillMode, \" \").concat(playState, \" \").concat(animationName)\n  } : null;\n  return [{\n    style: style,\n    play: play,\n    animationName: animationName\n  }, function (playValue) {\n    return playFunction(playValue);\n  }];\n}\n\nfunction useAnimateGroup(props) {\n  var nextDelaySeconds = 0;\n\n  var _useState = React.useState(props),\n      _useState2 = _slicedToArray(_useState, 2),\n      _useState2$ = _useState2[0],\n      sequences = _useState2$.sequences,\n      reverseSequences = _useState2$.reverseSequences,\n      play = _useState2$.play,\n      animationNames = _useState2$.animationNames,\n      setPlay = _useState2[1];\n\n  var playFunction = function playFunction(playValue) {\n    setPlay({\n      sequences: sequences,\n      reverseSequences: reverseSequences,\n      play: playValue,\n      animationNames: animationNames\n    });\n  };\n\n  React.useEffect(function () {\n    var localStyleTag;\n    var localAnimationNames = [];\n    sequences.forEach(function (_ref, i) {\n      var _ref$keyframes = _ref.keyframes,\n          keyframes = _ref$keyframes === void 0 ? false : _ref$keyframes;\n\n      if (keyframes) {\n        var animationName = createRandomName();\n        localAnimationNames[i] = animationName;\n\n        var _createTag = createTag({\n          animationName: animationName,\n          keyframes: keyframes\n        }),\n            styleTag = _createTag.styleTag;\n\n        localStyleTag = styleTag;\n      }\n    });\n    setPlay({\n      sequences: sequences,\n      play: play,\n      reverseSequences: reverseSequences,\n      animationNames: localAnimationNames\n    });\n    return function () {\n      if (localStyleTag) {\n        localAnimationNames.forEach(function (name) {\n          // $FlowIgnoreLine\n          deleteRules(localStyleTag.sheet, name);\n        });\n      }\n\n      localAnimationNames = [];\n    };\n  }, []);\n  var localSequences = (play ? sequences : reverseSequences) || [];\n  var styles = (reverseSequences ? localSequences : sequences).map(function (prop, i) {\n    var _prop$durationSeconds = prop.durationSeconds,\n        durationSeconds = _prop$durationSeconds === void 0 ? 0.3 : _prop$durationSeconds,\n        _prop$keyframes = prop.keyframes,\n        keyframes = _prop$keyframes === void 0 ? false : _prop$keyframes,\n        _prop$easeType = prop.easeType,\n        easeType = _prop$easeType === void 0 ? 'linear' : _prop$easeType,\n        _prop$delaySeconds = prop.delaySeconds,\n        delaySeconds = _prop$delaySeconds === void 0 ? 0 : _prop$delaySeconds,\n        _prop$iterationCount = prop.iterationCount,\n        iterationCount = _prop$iterationCount === void 0 ? 1 : _prop$iterationCount,\n        _prop$direction = prop.direction,\n        direction = _prop$direction === void 0 ? 'normal' : _prop$direction,\n        _prop$fillMode = prop.fillMode,\n        fillMode = _prop$fillMode === void 0 ? 'none' : _prop$fillMode,\n        _prop$playState = prop.playState,\n        stylePlayState = _prop$playState === void 0 ? 'running' : _prop$playState,\n        _prop$overlaySeconds = prop.overlaySeconds,\n        overlaySeconds = _prop$overlaySeconds === void 0 ? 0 : _prop$overlaySeconds;\n    nextDelaySeconds = durationSeconds + delaySeconds - overlaySeconds;\n    nextDelaySeconds = nextDelaySeconds < 0 ? 0 : nextDelaySeconds;\n\n    if (keyframes) {\n      return play ? {\n        styles: \"\".concat(durationSeconds, \"s \").concat(easeType, \" \").concat(i === 0 ? delaySeconds : nextDelaySeconds + delaySeconds, \"s \").concat(iterationCount, \" \").concat(direction, \" \").concat(fillMode, \" \").concat(stylePlayState, \" \").concat(animationNames[i])\n      } : null;\n    }\n\n    return attributesGenerator(_objectSpread({}, _objectSpread({}, prop, {\n      delaySeconds: i === 0 ? delaySeconds : nextDelaySeconds + delaySeconds\n    }), {\n      play: play\n    })).style;\n  });\n  return [{\n    styles: styles,\n    animationNames: animationNames,\n    play: play\n  }, playFunction];\n} //\n\n\nexports.Animate = animate;\nexports.AnimateGroup = AnimateGroup;\nexports.AnimateKeyframes = animateKeyframes;\nexports.useAnimate = useAnimate;\nexports.useAnimateKeyframes = useAnimateKeyframes;\nexports.useAnimateGroup = useAnimateGroup;","map":null,"metadata":{},"sourceType":"script"}